{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 2acfecb0e362d9cdde69","webpack:///external \"cheerio\"","webpack:///external \"lodash\"","webpack:///external \"request-promise\"","webpack:///external \"fs\"","webpack:///./src/helpers/loader.js","webpack:///./src/helpers/rule.js","webpack:///./src/index.js","webpack:///./src/helpers/index.js","webpack:///./src/helpers/linter.js","webpack:///./node_modules/babel-runtime/regenerator/index.js","webpack:///external \"regenerator-runtime\"","webpack:///external \"path\"","webpack:///external \"js-yaml\"","webpack:///./src/constants/index.js"],"names":["root","factory","exports","module","define","amd","a","i","self","this","installedModules","__webpack_require__","moduleId","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","require","request","cheerio","fs","path","yaml","loadYamlConfig","filename","config","resolve","existsSync","Promise","reject","cfg","safeLoad","readFileSync","err","Error","loadUrl","url","startsWith","uri","toLowerCase","headers","User-Agent","transform","body","load","then","$","loadFile","readFile","html","loadHTML","TagRule","tagName","_ref","parent","_ref$required","required","undefined","_ref$max","max","_ref$min","min","_ref$attrs","attrs","_ref$childs","childs","_classCallCheck","_tagName","SEOLinter","loader","_extends","_","ERROR_CODE","rules","isObject","errors","tags","initRules","_this","arguments","length","rulesMap","keys","forEach","rule","tagRules","isArray","createTagRules","createTagRule","concat","_toConsumableArray","cfgRule","isEmpty","key","cfgRules","_this2","map","_this3","tag","find","code","msg","message","_this4","_rulesMap$tagName","reduce","validateRule","_this5","_ref2","elmLen","trim","msgPrnt","push","createError","ERR_TAG_NOT_FOUND","ERR_TAG_MAX_EXCEED","ERR_TAG_MIN_UNDER","attrErrors","validateAttrs","_errs","_this6","attrNames","attrMap","attrNm","value","each","elm","present","matched","attrVal","attribs","_attrMap$attrNm","attr","notPresent","ERR_ATTR_NOT_FOUND","notMatched","errMsg","ERR_ATTR_NOT_EQUAL","file","output","type","silence","assignElement","_this7","validate","writeOut","indexOf","printErrors","createWriteStream","textToWrite","toOutputString","once","write","Buffer","end","on","_this8","str","_ref6","console","log"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 6);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 2acfecb0e362d9cdde69","module.exports = require(\"cheerio\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"cheerio\"\n// module id = 0\n// module chunks = 0 1","module.exports = require(\"lodash\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash\"\n// module id = 1\n// module chunks = 0 1","module.exports = require(\"request-promise\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"request-promise\"\n// module id = 2\n// module chunks = 0 1","module.exports = require(\"fs\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"fs\"\n// module id = 3\n// module chunks = 0","'use strict';\n\nconst request = require('request-promise');\nconst cheerio = require('cheerio');\nconst fs = require('fs');\nconst path = require('path');\nconst yaml = require('js-yaml');\n\n/**\n * Load yaml config file to javascript object\n *\n * @param {string} filename: provide the absolute path of yaml configuration file.\n * @param {string} config stands for key of configuration\n */\nexports.loadYamlConfig = (filename, config) => {\n  if (!filename) {\n    filename = path.resolve('config.yml');\n  }\n  if (!fs.existsSync(filename))\n    return Promise.reject(\n      new Error(`Provied path (${filename}) does not exist!`)\n    );\n\n  return new Promise((resolve, reject) => {\n    try {\n      const cfg = yaml.safeLoad(fs.readFileSync(filename, 'utf8'));\n      return config ? resolve(cfg[config]) : resolve(cfg);\n    } catch (err) {\n      reject(err);\n    }\n  });\n};\n\n/**\n * Load page content from url\n *\n * @param {string} url\n * @returns { $ } cheerio wrapped html tag\n * @example:\n * const { loadUrl } = require('./helper');\n * const { $ } = await loadUrl('https://google.com.vn');\n */\nexports.loadUrl = url => {\n  if (!url.startsWith('http://') && !url.startsWith('https://')) {\n    return false;\n  }\n  const uri = url.toLowerCase();\n  const options = {\n    uri,\n    headers: {\n      'User-Agent': 'Request-Promise'\n    },\n    transform: body => {\n      return cheerio.load(body);\n    }\n  };\n\n  return request(options).then($ => $('html'));\n};\n\n/**\n * Load page content from HTML file\n *\n * @param {string} html path\n * @returns { $ } cheerio wrapped html tag\n * @example:\n * const { loadFile } = require('./helper');\n * const { $ } = await loadFile('/path/to/htmlfile.html');\n */\nexports.loadFile = filename => {\n  if (!filename) return Promise.reject(new Error('Filename is required'));\n  // TODO: check if filename is readable stream, provide without reading file from path\n  if (!fs.existsSync(filename))\n    return Promise.reject(\n      new Error(`Path provied <${filename}> does not exist`)\n    );\n  return new Promise((resolve, reject) => {\n    fs.readFile(filename, (err, html) => {\n      if (err) return reject(err);\n      const $ = cheerio.load(html);\n      return resolve($('html'));\n    });\n  });\n};\n\n/**\n * Load page content from HTML string\n *\n * @param {string} html string\n * @returns { $ } cheerio wrapped html tag\n * @example:\n * const { loadHTML } = require('./helper');\n * const { $ } = await loadHTML('<html>...</html>');\n */\nexports.loadHTML = html => {\n  if (!html)\n    return Promise.reject(\n      new Error('HTML argument is required and it should not be empty')\n    );\n  const $ = cheerio.load(html);\n  return Promise.resolve($('html'));\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/helpers/loader.js","/**\n * TagRule\n *\n * max { -1 => Unlimited }\n * min { 0 => No required min }\n */\nclass TagRule {\n  constructor(\n    tagName,\n    { parent, required = false, max = -1, min = 0, attrs = {}, childs = [] }\n  ) {\n    if (!tagName) throw new Error('tagName is required');\n    this._tagName = tagName;\n    this.parent = parent;\n    this.required = required || false;\n    this.max = max || -1;\n    this.min = min || 0;\n    this.attrs = attrs || {};\n    this.childs = childs || [];\n  }\n\n  get tagName() {\n    return this._tagName;\n  }\n}\n\nmodule.exports = TagRule;\n\n\n\n// WEBPACK FOOTER //\n// ./src/helpers/rule.js","'use strict';\nconst { SEOLinter, loadYamlConfig } = require('./helpers');\n\nmodule.exports = {\n  SEOLinter,\n  loadYamlConfig\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","'use strict';\n\nconst SEOLinter = require('./linter');\nconst loader = require('./loader');\nconst TagRule = require('./rule');\n\nmodule.exports = {\n  SEOLinter,\n  TagRule,\n  ...loader\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/helpers/index.js","'use strict';\n\nconst _ = require('lodash');\nconst cheerio = require('cheerio');\nconst fs = require('fs');\n\nconst { loadUrl, loadHTML, loadFile } = require('./loader');\nconst TagRule = require('./rule');\nconst { ERROR_CODE } = require('../constants');\n\nclass SEOLinter {\n  constructor({ rules }) {\n    if (!rules) throw new Error('Rules is required!');\n    if (!_.isObject(rules)) throw new Error('Rules must be an object!');\n\n    this.errors = [];\n    this.tags = [];\n\n    //init rules\n    this.initRules(rules);\n  }\n\n  /**\n   * initilize rules of SEO Linter\n   *\n   * @param {Object} rules\n   */\n  initRules(rules = {}) {\n    this.rulesMap = {};\n    this.tags = Object.keys(rules);\n    this.tags.forEach(tagName => {\n      const rule = rules[tagName];\n      const tagRules = _.isArray(rule)\n        ? this.createTagRules(tagName, rule)\n        : [this.createTagRule(tagName, rule)];\n\n      if (this.rulesMap[tagName]) {\n        this.rulesMap[tagName]['rules'] = [\n          ...this.rulesMap[tagName]['rules'],\n          ...tagRules\n        ];\n      } else {\n        this.rulesMap[tagName] = { rules: tagRules };\n      }\n    });\n  }\n\n  /**\n   * Create TagRule instance based on configuration\n   *\n   * @param {Object} cfgRule\n   * @returns {TagRule} instance of TagRule\n   */\n  createTagRule(tagName, cfgRule, parent) {\n    if (!tagName) {\n      if (_.isEmpty(cfgRule)) throw new Error('Configuration is invalid');\n      tagName = Object.keys(cfgRule)[0];\n      cfgRule = cfgRule[tagName];\n    }\n    return new TagRule(tagName, { ...cfgRule, parent });\n  }\n\n  /**\n   * Create list of TagRule based of configurations\n   *\n   * @param {Array} cfgRules\n   * @returns {Array<TagRule>} list of TagRule\n   *\n   */\n  createTagRules(key, cfgRules) {\n    return cfgRules.map(rule => this.createTagRule(key, rule));\n  }\n\n  /**\n   * Assign Cheerio Element to Each rule\n   *\n   * @param {*} $ cheerio document object\n   */\n  assignElement($) {\n    this.tags.forEach(tag => {\n      this.rulesMap[tag]['$'] = $.find(tag);\n    });\n  }\n\n  /**\n   * Create an error that\n   */\n  createError(rule, code, msg) {\n    return {\n      code,\n      message: msg ? msg : `Error from <${rule.tagName}>`,\n      tagName: rule.tagName\n    };\n  }\n\n  /**\n   * Validate rule by tagName\n   *\n   * @param {string} tagName\n   * @returns {Array} errors - If errors is empty mean HTML document is valid with provided rules.\n   */\n  validate(tagName) {\n    const { rules, $ } = this.rulesMap[tagName];\n    return rules.reduce(\n      (errors, rule) => errors.concat(this.validateRule({ rule, $ })),\n      []\n    );\n  }\n\n  /**\n   * Validate each rule by TagRule instance\n   *\n   * @param {Object} param0 should be like this: { rule, $ }\n   * @param {*} errors\n   */\n  validateRule({ rule, $ }, errors = []) {\n    const { tagName, required, max, min, attrs, childs, parent } = rule;\n    if (parent) {\n      $ = $.find(tagName);\n    }\n    let elmLen = $.length;\n    if (tagName === 'head' && $.html().trim() === '') {\n      elmLen = 0;\n    }\n\n    // Check if required and existed first\n    if (required && elmLen === 0) {\n      const msgPrnt = parent ? `<${parent}> tag` : 'HTML document';\n      errors.push(\n        this.createError(\n          rule,\n          ERROR_CODE.ERR_TAG_NOT_FOUND,\n          `${msgPrnt} required <${tagName}> tag but it doesn't exist`\n        )\n      );\n      return errors;\n    }\n\n    // Check max of element in document\n    if (max !== -1 && elmLen > max) {\n      errors.push(\n        this.createError(\n          rule,\n          ERROR_CODE.ERR_TAG_MAX_EXCEED,\n          `The maximum element of <${tagName}> tag is ${max} but this HTML document has ${elmLen} <${tagName}> tags.`\n        )\n      );\n    }\n\n    // Check min of element in document\n    if (min !== 0 && elmLen < min) {\n      errors.push(\n        this.createError(\n          rule,\n          ERROR_CODE.ERR_TAG_MIN_UNDER,\n          `The minimum element of <${tagName}> tag is ${min} but this HTML document has ${elmLen} <${tagName}> tags.`\n        )\n      );\n    }\n\n    // Check attributes (Each attr has 2 prop. Ex: { required, value })\n    if (!_.isEmpty(attrs)) {\n      const attrErrors = this.validateAttrs(rule, $);\n      errors = errors.concat(attrErrors);\n    }\n\n    // Recursive with childs element\n    if (rule.childs.length > 0) {\n      errors = rule.childs.reduce(\n        (_errs, rule) =>\n          _errs.concat(\n            this.validateRule(\n              {\n                rule: this.createTagRule(null, rule, 'head'),\n                $\n              },\n              errors\n            )\n          ),\n        []\n      );\n    }\n    return errors;\n  }\n\n  /**\n   * Validate Attributes of each element\n   *    1. Check attr required or not\n   *    2. Check attr required & attr has specified value\n   *\n   * @param {TagRule} rule\n   * @param {*} $ DOMElement wrapped by cheerio object\n   */\n  validateAttrs(rule, $) {\n    const { attrs, parent } = rule;\n    const elmLen = $.length;\n    const attrNames = Object.keys(attrs);\n    const attrMap = {};\n    let attrErrors = [];\n\n    if (elmLen === 0)\n      return attrNames.map(attrNm =>\n        this.createError(\n          rule,\n          ERROR_CODE.ERR_TAG_NOT_FOUND,\n          `<${rule.tagName} ${attrNm}='${attrs[attrNm].value ||\n            ''}'> was not found in ${\n            parent ? '<' + parent + '> tag' : 'HTML document'\n          }`\n        )\n      );\n\n    $.each((_, elm) => {\n      // Loop each element and check attrs in each one.\n      attrNames.forEach(attrNm => {\n        const { value } = attrs[attrNm];\n        if (!attrMap.hasOwnProperty(attrNm)) {\n          // present stands for number of element that contains attr, matched stands for number of attr mached value\n          attrMap[attrNm] = { present: 0, matched: 0 };\n        }\n        const attrVal = elm.attribs[attrNm];\n        if (attrVal) {\n          attrMap[attrNm].present += 1;\n          if (attrVal == value && value) {\n            attrMap[attrNm].matched += 1;\n          }\n        }\n      });\n    });\n\n    attrNames.forEach(attrNm => {\n      const { present, matched } = attrMap[attrNm];\n      const attr = attrs[attrNm];\n      if (attr.required) {\n        const notPresent = elmLen - present;\n        if (notPresent > 0) {\n          attrErrors.push(\n            this.createError(\n              rule,\n              ERROR_CODE.ERR_ATTR_NOT_FOUND,\n              `There are ${notPresent} <${\n                rule.tagName\n              }> tags without [${attrNm}] attribute`\n            )\n          );\n        }\n      }\n\n      if (attr.value) {\n        const notMatched = elmLen - matched;\n        if (\n          notMatched > 0 &&\n          notMatched < elmLen &&\n          matched < (attr.min || 0)\n        ) {\n          let errMsg = `At least ${attr.min} <${\n            rule.tagName\n          }> tags must have attribute [${attrNm}='${\n            attr.value\n          }']. Need more ${attr.min - matched} <${rule.tagName} ${attrNm}='${\n            attr.value\n          }'> tags.`;\n          attrErrors.push(\n            this.createError(rule, ERROR_CODE.ERR_ATTR_NOT_EQUAL, errMsg)\n          );\n        }\n\n        if (notMatched === elmLen) {\n          attrErrors.push(\n            this.createError(\n              rule,\n              ERROR_CODE.ERR_ATTR_NOT_EQUAL,\n              `${parent ? '<' + parent + '> tag' : 'HTML'} required <${\n                rule.tagName\n              }> tag present with attribute [${attrNm}='${\n                attr.value\n              }'] but no one is valid`\n            )\n          );\n        }\n      }\n    });\n\n    return attrErrors;\n  }\n\n  /**\n   * Linting html or page by rules configuration\n   *\n   * @param { uri, html, file, rules}\n   *    Options required uri | html | file && rules && output\n   *    output is an object that has 2 props: { type, path }\n   *      output.type must be either of [console, file]\n   *      output.path required when output.type equals to file and file is a path\n   */\n  async lint({\n    uri,\n    html,\n    file,\n    rules,\n    output = { type: 'console', silence: false }\n  }) {\n    // Make sure that every argument present correctly\n    if (!uri && !html && !file)\n      throw new Error(\n        'You must provide either uri, html, file or readable stream for linting.'\n      );\n    if (rules) {\n      this.initRules(rules);\n    }\n\n    // create cheerio instance based on html content or loading from uri\n    let $;\n    if (uri) {\n      $ = await loadUrl(uri);\n    } else if (html) {\n      $ = await loadHTML(html);\n    } else if (file) {\n      $ = await loadFile(file);\n    }\n\n    // assign cheerio element object for reach rule.\n    this.assignElement($);\n\n    // Get all tags in rules configurations and validate each one.\n    this.errors = this.tags.reduce(\n      (errors, tag) => errors.concat(this.validate(tag)),\n      []\n    );\n\n    // If there is any invalid term, the errors size will be greater than 0\n    if (this.errors.length === 0) return this.errors;\n\n    return output && !output.silence ? this.errors : this.writeOut(output);\n  }\n\n  /**\n   * Write result to stdout or file\n   *\n   * @param {Object} output -> { type, file }\n   */\n  async writeOut(output) {\n    if (output) {\n      const { type } = output;\n      let file = null;\n      if (['console', 'file'].indexOf(type) === -1)\n        throw new Error(\n          `Output type [${type}] is not valid. Accepted output are [console, file]`\n        );\n\n      if (type === 'console') {\n        this.printErrors();\n        return this.errors;\n      }\n\n      if (type === 'file' && !output.path) {\n        throw new Error('Provied path must be correct and existed');\n      }\n\n      if (typeof output.path === 'string') {\n        file = fs.createWriteStream(output.path);\n      } else {\n        file = output.path;\n      }\n\n      const textToWrite = this.toOutputString();\n\n      return new Promise((resolve, reject) => {\n        file.once('open', () => {\n          file.write(new Buffer(textToWrite, 'utf8'));\n          file.end();\n        });\n\n        file.on('finish', () => {\n          resolve(this.errors);\n        });\n      });\n    }\n  }\n\n  /**\n   * Create result string with line by line style\n   *\n   * @returns {string}\n   */\n  toOutputString() {\n    let str = '';\n    let i = 0;\n    this.errors.forEach(({ code, message }) => {\n      str += `[${++i}][${code}] ${message}\\n`;\n    });\n    return str;\n  }\n\n  /**\n   * Show result string in console\n   *\n   */\n  printErrors() {\n    console.log(this.toOutputString());\n  }\n}\n\nmodule.exports = SEOLinter;\n\n\n\n// WEBPACK FOOTER //\n// ./src/helpers/linter.js","module.exports = require(\"regenerator-runtime\");\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/babel-runtime/regenerator/index.js\n// module id = 9\n// module chunks = 0","module.exports = require(\"regenerator-runtime\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"regenerator-runtime\"\n// module id = 10\n// module chunks = 0","module.exports = require(\"path\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"path\"\n// module id = 11\n// module chunks = 0","module.exports = require(\"js-yaml\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"js-yaml\"\n// module id = 12\n// module chunks = 0","exports.ERROR_CODE = {\n  ERR_TAG_NOT_FOUND: 'TAG001', // Tag required but not existed\n  ERR_TAG_MAX_EXCEED: 'TAG002', // Tag required total of element is X but has exceed the limit\n  ERR_TAG_MIN_UNDER: 'TAG003', // Tag required total of element is Y but has under the limit\n  ERR_ATTR_NOT_FOUND: 'ATTR001', // Tag requires attr present but not\n  ERR_ATTR_NOT_EQUAL: 'ATTR002' // Tag requires attr present with value but not\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/constants/index.js"],"sourceRoot":""}